/*
 * Order.java
 *
 */
package com.ib.client;

import java.util.Vector;

public class Order {
    final public static int 	CUSTOMER = 0;
    final public static int 	FIRM = 1;
    final public static char    OPT_UNKNOWN='?';
    final public static char    OPT_BROKER_DEALER='b';
    final public static char    OPT_CUSTOMER ='c';
    final public static char    OPT_FIRM='f';
    final public static char    OPT_ISEMM='m';
    final public static char    OPT_FARMM='n';
    final public static char    OPT_SPECIALIST='y';
    final public static int 	AUCTION_MATCH = 1;
    final public static int 	AUCTION_IMPROVEMENT = 2;
    final public static int 	AUCTION_TRANSPARENT = 3;
    final public static String  EMPTY_STR = "";

    // Basic order fields
    public int 		m_orderId;         // order id generated by API client
    public int 		m_clientId;        // client id of the API client that submitted the order
    public int  	m_permId;          // TWS order ID (not specified by API)
    public String 	m_action;          // specify BUY or SELL; non-cleared customers can specify SSHORT
    public int 		m_totalQuantity;   // order size
    public String 	m_orderType;       // order type, e.g. LMT, MKT, STOP, TRAIL, REL
    public double 	m_lmtPrice;        // limit price 
    public double 	m_auxPrice;        // stop price, trailing amount, or offset amount 
    public String   m_account;         // IB account; can be left blank for users with only a single account

    // Advanced order fields
    public String 	m_tif;             // Time in force, e.g. DAY, GTC
    public String 	m_ocaGroup;        // OCA group ("one cancels all")
    public int      m_ocaType;         // OCA group type  1 = CANCEL_WITH_BLOCK, 2 = REDUCE_WITH_BLOCK, 3 = REDUCE_NON_BLOCK
    public String 	m_orderRef;        // order reference, enter any free-form text
    public boolean 	m_transmit;	       // if false, order will be created in TWS but not transmited
    public int 		m_parentId;	       // order id of parent order, to associate attached stop, trailing stop, or bracket orders with parent order
    public boolean 	m_blockOrder;      // block order, for ISE option orders only
    public boolean	m_sweepToFill;     // for SMART orders, specifies that orders should be split and sent to multiple exchanges at the same time
    public int 		m_displaySize;     // the portion of the order that will be visible to the world
    public int 		m_triggerMethod;   // for stop orders:  0=Default, 1=Double_Bid_Ask, 2=Last, 3=Double_Last, 4=Bid_Ask, 7=Last_or_Bid_Ask, 8=Mid-point
    public boolean 	m_outsideRth;      // if true, order could fill or trigger anytime; if false, orer will fill or trigger only during regular trading hours
    public boolean  m_hidden;          // if true, order will be hidden, and will not be reflected in the market data or deep book
    public String   m_goodAfterTime;   // format: YYYYMMDD HH:MM:SS  e.g. 20060505 08:00:00 EST
    public String   m_goodTillDate;    // format: YYYYMMDD HH:MM:SS  e.g. 20060505 08:00:00 EST
    public boolean  m_overridePercentageConstraints; // set true to override normal percentage constraint checks
    public String   m_rule80A;         // Individual = 'I', Agency = 'A', AgentOtherMember = 'W', IndividualPTIA = 'J', AgencyPTIA = 'U', AgentOtherMemberPTIA = 'M', IndividualPT = 'K', AgencyPT = 'Y', AgentOtherMemberPT = 'N'
    public boolean  m_allOrNone;       // if set to true, there can be no partial fills for the order
    public int      m_minQty;          // no partial fills less than the size specified here
    public double   m_percentOffset;   // the offset amount for Relative (REL) orders, specified as a percent; specify either this OR the offset amount in m_auxPrice
    public double   m_trailStopPrice;  // initial stop price for trailing stop (TRAIL) orders

    // For Financial advisors (FA) only 
    public String   m_faGroup;            // Advisor group, e.g. "All"
    public String   m_faMethod;           // Advisor method: PctChange, AvailableEquity, NetLiq, or EqualQuantity
    public String   m_faPercentage;       // Advisor percentage, used when the method is set to PctChange
    public String   m_faProfile;          // Advisor profile

    // For non-cleared customers only
    public String 	m_openClose;          // open/close flag: O=Open, C=Close
    public int 		m_origin;             // origin: 0=Customer, 1=Firm
    public int      m_shortSaleSlot;      // specify only if m_action is "SSHORT": 1 if you hold the shares, 2 if they will be delivered from elsewhere
    public String   m_designatedLocation; // specifies where the shares are held; set only when m_shortSaleSlot=2
    public String   m_settlingFirm;       // give-up/settling firm (for non-cleared customers only)
    public String   m_clearingAccount;    // true beneficiary of the order
    public String   m_clearingIntent;     // "" (Default), "IB", "Away", "PTA" (PostTrade)

    // SMART routing only
    public double   m_discretionaryAmt;   // amount you are willing to pay above your specified limit price
    public boolean  m_firmQuoteOnly;      // if true, specifies that order should be routed to exchanges showing a "firm" quote...
    public double   m_nbboPriceCap;       // ...but not if the exchange is off the NBBO by more than this amount

    // For BOX option-pegged-to-stock orders only
    public double   m_startingPrice;
    public double   m_stockRefPrice;
    public double   m_delta;

    // For Pegged-to-stock or Volatility orders only
    public double   m_stockRangeLower;          // if stock price moves below this price, order will be canceled
    public double   m_stockRangeUpper;          // if stock price moves above this price, order will be canceled

    // For Volatility orders only
    public double   m_volatility;               // volatility (percent)
    public int      m_volatilityType;           // volatility type: 1=daily, 2=annual
    public int      m_continuousUpdate;         // if true, price will be continuously recalculated after order submission
    public int      m_referencePriceType;       // what to use as the current stock price: 1=bid/ask average, 2 = bid or ask
    public String   m_deltaNeutralOrderType;
    public double   m_deltaNeutralAuxPrice;

    // For EFP orders only 
    public double   m_basisPoints;              // EFP orders only
    public int      m_basisPointsType;          // EFP orders only
    
    // For Scale orders only
    public int      m_scaleInitLevelSize;       // size of first component order
    public int      m_scaleSubsLevelSize;       // size of subsequent component orders
    public double   m_scalePriceIncrement;      // price increment (down for buy, up for sell)

    // For Scale order with "profit-taker" only
    public double m_scaleProfitOffset;          // profit offset (up for buy, down for sell)
    public boolean m_scaleRestoreSize;          // if true, size is transferred to the main order when the profit taker fills
    public double m_scalePriceAdjustValue;      // if true, the enter scale is move down by this amount every interval
    public int m_scalePriceAdjustInterval;      // the time interval for adjusting the price (in seconds)
    public int m_scaleInitialPosition;          // initial position (pre-fills some price levels)
    public int m_scaleFilledInitialComponentSize;

    // ALGO ORDERS ONLY
    public String m_algoStrategy;
    public Vector m_algoParams;

    // What-if
    public boolean  m_whatIf;             // if true, the order will not be submitted, but margin info will be returned
    
    // obsolete
    public boolean  m_eTradeOnly;         // this field is obsolete
    public int      m_auctionStrategy;    // this field is obsolete


    public Order() {
    	m_outsideRth = false;
        m_openClose	= "O";
        m_origin = CUSTOMER;
        m_transmit = true;
        m_designatedLocation = EMPTY_STR;
        m_minQty = Integer.MAX_VALUE;
        m_percentOffset = Double.MAX_VALUE;
        m_nbboPriceCap = Double.MAX_VALUE;
        m_startingPrice = Double.MAX_VALUE;
        m_stockRefPrice = Double.MAX_VALUE;
        m_delta = Double.MAX_VALUE;
        m_stockRangeLower = Double.MAX_VALUE;
        m_stockRangeUpper = Double.MAX_VALUE;
        m_volatility = Double.MAX_VALUE;
        m_volatilityType = Integer.MAX_VALUE;
        m_deltaNeutralOrderType = EMPTY_STR;
        m_deltaNeutralAuxPrice = Double.MAX_VALUE;
        m_referencePriceType = Integer.MAX_VALUE;
        m_trailStopPrice = Double.MAX_VALUE;
        m_basisPoints = Double.MAX_VALUE;
        m_basisPointsType = Integer.MAX_VALUE;
        m_scaleInitLevelSize = Integer.MAX_VALUE;
        m_scaleSubsLevelSize = Integer.MAX_VALUE;
        m_scalePriceIncrement = Double.MAX_VALUE;
        m_scaleProfitOffset = Double.MAX_VALUE;
        m_scalePriceAdjustValue = Double.MAX_VALUE;
        m_scalePriceAdjustInterval = Integer.MAX_VALUE;
        m_scaleInitialPosition = Integer.MAX_VALUE;
        m_scaleFilledInitialComponentSize = Integer.MAX_VALUE;
        
        m_whatIf = false;
    }

    public boolean equals(Object p_other) {

        if ( this == p_other )
            return true;

        if ( p_other == null )
            return false;

        Order l_theOther = (Order)p_other;

        if ( m_permId == l_theOther.m_permId ) {
            return true;
        }

        if (m_orderId != l_theOther.m_orderId ||
        	m_clientId != l_theOther.m_clientId ||
        	m_totalQuantity != l_theOther.m_totalQuantity ||
        	m_lmtPrice != l_theOther.m_lmtPrice ||
        	m_auxPrice != l_theOther.m_auxPrice ||
        	m_ocaType != l_theOther.m_ocaType ||
        	m_transmit != l_theOther.m_transmit ||
        	m_parentId != l_theOther.m_parentId ||
        	m_blockOrder != l_theOther.m_blockOrder ||
        	m_sweepToFill != l_theOther.m_sweepToFill ||
        	m_displaySize != l_theOther.m_displaySize ||
        	m_triggerMethod != l_theOther.m_triggerMethod ||
        	m_outsideRth != l_theOther.m_outsideRth ||
        	m_hidden != l_theOther.m_hidden ||
        	m_overridePercentageConstraints != l_theOther.m_overridePercentageConstraints ||
        	m_allOrNone != l_theOther.m_allOrNone ||
        	m_minQty != l_theOther.m_minQty ||
        	m_percentOffset != l_theOther.m_percentOffset ||
        	m_trailStopPrice != l_theOther.m_trailStopPrice ||
        	m_origin != l_theOther.m_origin ||
        	m_shortSaleSlot != l_theOther.m_shortSaleSlot ||
        	m_discretionaryAmt != l_theOther.m_discretionaryAmt ||
        	m_eTradeOnly != l_theOther.m_eTradeOnly ||
        	m_firmQuoteOnly != l_theOther.m_firmQuoteOnly ||
        	m_nbboPriceCap != l_theOther.m_nbboPriceCap ||
        	m_auctionStrategy != l_theOther.m_auctionStrategy ||
        	m_startingPrice != l_theOther.m_startingPrice ||
        	m_stockRefPrice != l_theOther.m_stockRefPrice ||
        	m_delta != l_theOther.m_delta ||
        	m_stockRangeLower != l_theOther.m_stockRangeLower ||
        	m_stockRangeUpper != l_theOther.m_stockRangeUpper ||
        	m_volatility != l_theOther.m_volatility ||
        	m_volatilityType != l_theOther.m_volatilityType ||
        	m_continuousUpdate != l_theOther.m_continuousUpdate ||
        	m_referencePriceType != l_theOther.m_referencePriceType ||
        	m_deltaNeutralAuxPrice != l_theOther.m_deltaNeutralAuxPrice ||
        	m_basisPoints != l_theOther.m_basisPoints ||
        	m_basisPointsType != l_theOther.m_basisPointsType ||
        	m_scaleInitLevelSize != l_theOther.m_scaleInitLevelSize ||
        	m_scaleSubsLevelSize != l_theOther.m_scaleSubsLevelSize ||
        	m_scalePriceIncrement != l_theOther.m_scalePriceIncrement ||
        	m_whatIf != l_theOther.m_whatIf) {
        	return false;
        }
        
        if (Util.StringCompare(m_action, l_theOther.m_action) != 0 ||
        	Util.StringCompare(m_orderType, l_theOther.m_orderType) != 0 ||
        	Util.StringCompare(m_tif, l_theOther.m_tif) != 0 ||
        	Util.StringCompare(m_ocaGroup, l_theOther.m_ocaGroup) != 0 ||
        	Util.StringCompare(m_orderRef,l_theOther.m_orderRef) != 0 ||
        	Util.StringCompare(m_goodAfterTime, l_theOther.m_goodAfterTime) != 0 ||
        	Util.StringCompare(m_goodTillDate, l_theOther.m_goodTillDate) != 0 ||
        	Util.StringCompare(m_rule80A, l_theOther.m_rule80A) != 0 ||
        	Util.StringCompare(m_faGroup, l_theOther.m_faGroup) != 0 ||
        	Util.StringCompare(m_faProfile, l_theOther.m_faProfile) != 0 ||
        	Util.StringCompare(m_faMethod, l_theOther.m_faMethod) != 0 ||
        	Util.StringCompare(m_faPercentage, l_theOther.m_faPercentage) != 0 ||
        	Util.StringCompare(m_openClose, l_theOther.m_openClose) != 0 ||
        	Util.StringCompare(m_designatedLocation, l_theOther.m_designatedLocation) != 0 ||
        	Util.StringCompare(m_deltaNeutralOrderType, l_theOther.m_deltaNeutralOrderType) != 0 ||
        	Util.StringCompare(m_account, l_theOther.m_account) != 0 ||
        	Util.StringCompare(m_settlingFirm, l_theOther.m_settlingFirm) != 0 ||
        	Util.StringCompare(m_clearingAccount, l_theOther.m_clearingAccount) != 0 ||
        	Util.StringCompare(m_clearingIntent, l_theOther.m_clearingIntent) != 0 ||
        	Util.StringCompare(m_algoStrategy, l_theOther.m_algoStrategy) != 0) {
        	return false;
        }
        
        if (!Util.VectorEqualsUnordered(m_algoParams, l_theOther.m_algoParams)) {
        	return false;
        }

        return true;
    }
    
    public String toString() {
        return m_action + " " + m_totalQuantity + " at " + m_lmtPrice + " (" + m_orderId + ")";
    }
}